[{"authors":["admin"],"categories":null,"content":"I am currently an Associate Professor at the University of Lille and I\u0026rsquo;m part of the RMoD team led by Stéphane Ducasse. My current research interests are focused on dynamic object-oriented languages and the Pharo language, debugging and interoperability between dynamic languages.\nBefore this position, I was R\u0026amp;D project manager at Axellience, startup created in 2012 by Alexis Muller and editor of the GenMyModel platform. I was conducting research related to Model Driven Engineering and language engineering. More specifically, I was working on heterogeneous model repositories, collaboration, architecture modernization using backward/forward engineering, and MDE scalability in the Cloud.\nFrom 2011 to 2012, I had a one-year position as researcher/lecturer at the University of Technology of Lille 1 (IUT) where I worked with Anne Etien on automatic model transformation chaining using static analysis and product lines. Before that, I obtained a PhD degree from the University of Lille 1 in the DaRT research team at INRIA Lille with Anne Etien and Professor Jean-Luc Dekeyser where I worked on model debugging/profiling and MDE compilation chain debugging, using traceability.\nDuring my \u0026ldquo;young ages\u0026rdquo;, I worked on the relationship between metamodel and UML profile in the MACAO team from the IRIT under the direction of the Professor Christian Percebois. I also briefly worked on formal verification of a Signal to C compiler under supervision of Martin Strecker in the ACADIE team at IRIT.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/author/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/","section":"authors","summary":"I am currently an Associate Professor at the University of Lille and I\u0026rsquo;m part of the RMoD team led by Stéphane Ducasse. My current research interests are focused on dynamic object-oriented languages and the Pharo language, debugging and interoperability between dynamic languages.","tags":null,"title":"","type":"authors"},{"authors":["Steven Costiou","Vincent Aranega","Marcus Denker"],"categories":[],"content":"","date":1580515200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1604659133,"objectID":"ea1aaafc37df14be1fc6c593a6b7e31f","permalink":"/publication/programming-20/","publishdate":"2020-11-06T10:38:52.941873Z","relpermalink":"/publication/programming-20/","section":"publication","summary":"","tags":[],"title":"Sub-method, partial behavioral reflection with Reflectivity: Looking back on 10 years of use","type":"publication"},{"authors":["Pierre Misse-Chanabier","Vincent Aranega","Guillermo Polito","Stéphane Ducasse"],"categories":[],"content":"","date":1564617600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1604659132,"objectID":"3c4d001646e5a70dd981fd2d80aad88a","permalink":"/publication/iwst-19/","publishdate":"2020-11-06T10:38:52.810801Z","relpermalink":"/publication/iwst-19/","section":"publication","summary":"","tags":["\"Transpilation ; Pharo ; C language ; Tools\""],"title":"Illicium A modular transpilation toolchain from Pharo to C","type":"publication"},{"authors":["Thomas Dupriez","Guillermo Polito","Steven Costiou","Vincent Aranega","Stéphane Ducasse"],"categories":[],"content":"","date":1546300800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1604659133,"objectID":"ab0fb8d9cac088a10b09e5e768078648","permalink":"/publication/sdl-19/","publishdate":"2020-11-06T10:38:53.072045Z","relpermalink":"/publication/sdl-19/","section":"publication","summary":"Debugging is one of the most important and time consuming activities in software maintenance, yet mainstream debuggers are not well-adapted to several debugging scenarios. This has led to the research of new techniques covering specific families of complex bugs. Notably, recent research proposes to empower developers with scripting DSLs, plugin-based and moldable debuggers. However, these solutions are tailored to specific use-cases, or too costly for one-time-use scenarios. In this paper we argue that exposing a debugging scripting interface in mainstream debuggers helps in solving many challenging debugging scenarios. For this purpose, we present Sindarin, a scripting API that eases the expression and automation of different strategies developers pursue during their debugging sessions. Sindarin provides a GDB-like API, augmented with AST-bytecode-source code mappings and object-centric capabilities. To demonstrate the versatility of Sindarin, we reproduce several advanced breakpoints and non-trivial debugging mechanisms from the literature.","tags":["\"scripting\"","\"Pharo\"","\"object centrics\"","\"debugging\""],"title":"Sindarin: A Versatile Scripting API for the Pharo Debugger","type":"publication"},{"authors":null,"categories":null,"content":"Since the beginning of my PhD, I\u0026rsquo;m an assistant teacher. I have given courses to the University Lille 1 from 2008 to 2011, the University Institute of Technology of Lille 1 from 2011 to 2012, and since 2012, I teach to Polytech\u0026rsquo;Lille (Engineer School):\n Polytech\u0026rsquo;Lille  Model Driven Engineering Advanced C Programming System Programming Language \u0026amp; Compiler Computer/System Architecture Low-Level Architecture Shell Programming   IUT of Lille:  Computer Architecture/Assembly Programming C Programming Advanced Data Structures Computer Sciences Basics   University of Lille:  Functionnal Programming Operating System Architecture Advanced Database C Programming Programming Langages Paradigmes Metamodeling    Service details (in French)\n","date":1546300800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1546300800,"objectID":"322dbaccf72a6d71f827fdb2866be935","permalink":"/teaching/","publishdate":"2019-01-01T00:00:00Z","relpermalink":"/teaching/","section":"","summary":"Since the beginning of my PhD, I\u0026rsquo;m an assistant teacher. I have given courses to the University Lille 1 from 2008 to 2011, the University Institute of Technology of Lille 1 from 2011 to 2012, and since 2012, I teach to Polytech\u0026rsquo;Lille (Engineer School):","tags":null,"title":"Teaching","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":1475596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1475596800,"objectID":"0ee65d312660fd75a9f998b80062ab80","permalink":"/talk/commitmde-talk/","publishdate":"2016-10-04T16:00:00Z","relpermalink":"/talk/commitmde-talk/","section":"talk","summary":"Collaboration in MDE is a large subject and gathers two main concerns: collaboration with MDE and for MDE. The first one refers to collaboration using MDE tools whereas the second one focuses on creating collaborative MDE tools, i.e: being able to propose a collaborative experience in an MDE tool. When it comes to collaboration for MDE and to modeling tools, we assume that col- laboration could be view as a time related problematic where past, present and future are all important. This talk discusses that last assumption and binds these notions to a concurrency problematic for modeling activities. Either the modifications are concurrent or they are not. In both cases, the theorical point of view is developed as well as more general questions around ergonomy. Using these concepts of con- currency, the talk explains how collaborative modeling is a matter of conducting the present while always keeping track of the past and, somehow, dealing with the future. In order to illustrate as well as possible the different points of view and concepts, the talk will evolve around the GenMyModel collaborative modeling tool. After a brief overview of the platform, we will show how collaboration can mean managing model modifications over time and the effort we put in place in order to offer efficient solutions for concurrent and non-concurrent modifications over a single resource (model). Beside the temporal aspect of collaborative modeling, the presentation will also discuss the performance and the infrastructure choices for the GenMyModel platform, as well as the advantages and drawback of using a cloud-based solution. Finally, I will present work in progress and future work about collaboration on different levels (code against model).","tags":null,"title":"MDE Collaboration: Temporality and Ergonomy in the Cloud, the GenMyModel Solution","type":"talk"},{"authors":["Vincent Aranega","Jean-Marie Mottu","Anne Etien","Thomas Degueule","Benoit Baudry","Jean-Luc Dekeyser"],"categories":[],"content":"","date":1420070400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1420070400,"objectID":"861bfc7c9736187e5f3ab4cf66f569ec","permalink":"/publication/stvr15/","publishdate":"2019-09-19T14:28:05+02:00","relpermalink":"/publication/stvr15/","section":"publication","summary":"","tags":[],"title":"Towards an automation of the mutation analysis dedicated to model transformation","type":"publication"},{"authors":["Vincent Aranega","Antonio Wendell De Oliveira Rodrigues","Anne Etien","Frederic Guyomarch'","Jean-Luc Dekeyser"],"categories":[],"content":"","date":1404172800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1404172800,"objectID":"327be43b0bbfffb0841c0615b47d6165","permalink":"/publication/ijsea14/","publishdate":"2019-09-19T14:09:42+02:00","relpermalink":"/publication/ijsea14/","section":"publication","summary":"","tags":[],"title":"Integrating Profiling into MDE Compilers","type":"publication"},{"authors":["Michel Dirix","Alexis Muller","Vincent Aranega"],"categories":[],"content":"","date":1356998400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1604659721,"objectID":"b0cc40836e10fdd0776d01670a0e3976","permalink":"/publication/ecoop-13/","publishdate":"2020-11-06T10:48:41.68498Z","relpermalink":"/publication/ecoop-13/","section":"publication","summary":"","tags":[],"title":"GenMyModel : An Online UML Case Tool","type":"publication"},{"authors":["Vincent Aranega","Anne Etien","Sébastien Mosser"],"categories":[],"content":"","date":1349049600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1604659722,"objectID":"21a600caf15cdbdde3687d0b6344195e","permalink":"/publication/models-12/","publishdate":"2020-11-06T10:48:41.93692Z","relpermalink":"/publication/models-12/","section":"publication","summary":"","tags":[],"title":"Using Feature Model to Build Model Transformation Chains","type":"publication"},{"authors":["Anne Etien","Vincent Aranega","Xavier Blanc","Richard F. Paige"],"categories":[],"content":"","date":1325376000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1604659721,"objectID":"775431cd37277d0ae6378449c75783f1","permalink":"/publication/amt-12/","publishdate":"2020-11-06T10:48:41.419796Z","relpermalink":"/publication/amt-12/","section":"publication","summary":"","tags":[],"title":"Chaining Model Transformations","type":"publication"},{"authors":["Antonio Wendell De Oliveira Rodrigues","Vincent Aranega","Anne Etien","Frédéric Guyomarc'H","Jean-Luc Dekeyser"],"categories":[],"content":"","date":1312156800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1604659722,"objectID":"595262b2accb642cb21466b873a7259a","permalink":"/publication/rr-11/","publishdate":"2020-11-06T10:48:42.442274Z","relpermalink":"/publication/rr-11/","section":"publication","summary":"","tags":[],"title":"Enabling Traceability in an MDE Approach to Improve Performance of GPU Applications","type":"publication"},{"authors":["Vincent Aranega","Jean-Marie Mottu","Anne Etien","Jean-Luc Dekeyser"],"categories":[],"content":"","date":1301616000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1301616000,"objectID":"27cb0682ddfa76d63468c5389b68d920","permalink":"/publication/sdt11/","publishdate":"2019-09-19T14:25:35+02:00","relpermalink":"/publication/sdt11/","section":"publication","summary":"","tags":[],"title":"Using Trace to Situate Errors in Model Transformations","type":"publication"},{"authors":["Vincent Aranega","Anne Etien","Jean-Luc Dekeyser"],"categories":[],"content":"","date":1293840000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1293840000,"objectID":"6ddacfcdc07582204771c3386c04a1b4","permalink":"/publication/eceasst/","publishdate":"2019-09-19T14:04:23+02:00","relpermalink":"/publication/eceasst/","section":"publication","summary":"","tags":[],"title":"Using an Alternative Trace for QVT","type":"publication"},{"authors":["Vincent Aranega","Jean-Marie Mottu","Anne Etien","Jean-Luc Dekeyser"],"categories":[],"content":"","date":1285891200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1604659722,"objectID":"de334e999ec1092d79e9f625ca8b84a3","permalink":"/publication/modevva-10-b/","publishdate":"2020-11-06T10:48:42.20692Z","relpermalink":"/publication/modevva-10-b/","section":"publication","summary":"","tags":[],"title":"Traceability for Mutation Analysis in Model Transformation","type":"publication"},{"authors":["Vincent Aranega","Anne Etien","Jean-Luc Dekeyser"],"categories":[],"content":"","date":1285891200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1285891200,"objectID":"23d36b7ed26620b5f6947aa48fd0a1ea","permalink":"/publication/mpm10/","publishdate":"2019-09-19T14:21:22+02:00","relpermalink":"/publication/mpm10/","section":"publication","summary":"","tags":[],"title":"Using an Alternative Trace for QVT","type":"publication"},{"authors":["Vincent Aranega","Jean-Marie Mottu","Anne Etien","Jean-Luc Dekeyser"],"categories":[],"content":"","date":1285891200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1604659722,"objectID":"cd8a8db52a361391b6de4becee343535","permalink":"/publication/modevva-10/","publishdate":"2020-11-06T10:48:42.063671Z","relpermalink":"/publication/modevva-10/","section":"publication","summary":"","tags":[],"title":"Using Traceability to Enhance Mutation Analysis Dedicated to Model Transformation","type":"publication"},{"authors":["Vincent Aranega","Jean-Marie Mottu","Anne Etien","Jean-Luc Dekeyser"],"categories":[],"content":"","date":1246406400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1604659721,"objectID":"ade0c572da6e1dc499caf938511c01e8","permalink":"/publication/icsoft-09/","publishdate":"2020-11-06T10:48:41.807821Z","relpermalink":"/publication/icsoft-09/","section":"publication","summary":"","tags":[],"title":"Traceability mechanism for error localization in model transformation","type":"publication"},{"authors":["Xiao Jing","Pierre Pinel","Lei Pi","Vincent Aranega","Claude Baron"],"categories":[],"content":"","date":1199145600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1604659721,"objectID":"bb2d21a288b3f153623d8379aff00c55","permalink":"/publication/comad-08/","publishdate":"2020-11-06T10:48:41.554233Z","relpermalink":"/publication/comad-08/","section":"publication","summary":"","tags":[],"title":"Modeling Uncertain and Imprecise Information in Process Modeling with UML","type":"publication"},{"authors":null,"categories":null,"content":"Introduction Le but de ce TP est d’implémenter en OCaml un interpréteur Magistack (https://esolangs.org/wiki/MagiStack), une machine virtuelle minimale à pile. Il y a plusieurs façons de proposer une solution, mais nous allons nous concentrer sur une en particulier.\n De manière générale, une machine virtuelle (VM) est un programme qui va lire et donner du sens à un ensemble d’instructions. Ces instructions sont encodées d’une certaine manière et chacune de ces instructions représente une action que la machine virtuelle doit effectuer. Dans les VM à pile, la machine virtuelle considère pour gérer ses opérations une pile sur laquelle elle pousse, enlève des valeurs…​etc. Les instructions qu’une VM à pile est capable de comprendre sont donc fortement à la manipulation de la pile.\n La VM que vous allez implémenter ici (ou commencer à implémenter), est une VM \u0026#34;jouet\u0026#34;. Elle ne considère que très peu d’instructions. Chaque instruction est encodée sur un caractère, et un programme est une longue chaine de caractère où chacun d’eux est donc une instruction. À chaque \u0026#34;étape\u0026#34; de l’exécution d’un programme, la VM va décoder un des caractères et faire ce que le symbole indique.\n Pour coder cette VM en OCaml, vous allez devoir recoder ce comportement général, à savoir : évoluer dans un programme, vers la gauche ou la droite (en fonction des actions), pour regarder quelle est l’action et effectuer l’action en question.\n   Représentation des concepts Si on regarde bien, il y a très peu de concepts qui vont être manipulés par notre VM. Essayez de vous poser quelques instants pour réfléchir au problème (on en discute ensemble évidemment).\n  Quels concepts voyez-vous qui vont être indispensable à la réalisation de la VM ?\n  Parmi ces concepts, comment vais-je les représenter ? (quelle structure je peux utiliser pour les représenter)\n  Imaginez que vous avez une fonction générale eval_program, quels vont être les paramètres que vous allez passer à la fonction ?\n  Imaginez maintenant que vous avec une fonction très spécifique qui est responsable de l’exécution de votre programme. Combien de concepts pensez-vous qu’il est nécessaire de passer à cette fonction ? Que vont-ils représenter ?\n  À un instant T, qu’est-ce qui va donner l’état de ma VM en cour d’exécution ?\n     Première étape de \u0026#34;compilation\u0026#34; de notre programme Comme vous l’avez peut-être deviner, travailler directement sur notre programme sous forme de chaine de caractère n’est pas très pratique. Nous allons donc \u0026#34;compiler\u0026#34; notre programme pour nous retrouver avec une représentation qui va être plus facile à manipuler en mémoire. L’idée générale va être de considérer que notre programme sous forme de chaine de caractère va être transformé en une liste d’instructions. Pour produire cette liste à partir d’une chaine de caractère, il est plus facile de passer par une première étape qui va prendre la chaine de caractère et la \u0026#34;couper\u0026#34; en une liste de caractère. Vous pouvez vous servir de la fonction suivante pour faire ça :\n let explode s = List.init (String.length s) (String.get s);;    Proposez un type algébrique pour représenter les instructions\n  Ecrivez une fonction qui va prendre une liste de caractère et la transforme en liste d’instructions\n  Ecrivez une fonction qui prend une chaine de caractère et la transforme en liste d’instructions\n     Modélisation de la pile et de la VM et avancer dans un programme Nous allons maintenant regarder comment nous pouvons modéliser le fait d’avancer dans un programme, la pile et la VM.\n  Comment peut-on représenter le fait qu’on avance dans un programme à chaque fois qu’on lit une instruction ?\n  Comment peut-on représenter la pile ?\n  Comment peut-on représenter la VM en elle-même ? A-t-on besoin d’une structure de donnée spéciale ou un ensemble de fonctions suffit ?\n     Comportement des instructions et de la VM Il est possible d’associer une fonction à chacune des instructions. Regardez bien sur le site de présentation du langage (https://esolangs.org/wiki/MagiStack) quelles sont les différentes instructions et ce qu’elles font.\n  Ecrivez une fonction pour chacune de ces instructions. Faites bien attention à ce qu’elles prennent en entrée et comment elles agissent sur le système pour le modifier (donc, que prennent-elles en entrée et que produisent-elle en sortie).\n  Ecrivez une fonction spéciale pour la VM qui prend une liste d’instructions (à voir comment vous la représentez exactement, discutons en), une stack vide et qui exécute le programme.\n  Ecrivez une fonction qui prend un programme sous forme de caractère et qui l’exécute en vous servant de toutes les fonctions précédentes.\n     ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"48348ace62998997dbdcce3e3c1cd33c","permalink":"/courses/c3p/tp4bis/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/c3p/tp4bis/","section":"courses","summary":"Introduction Le but de ce TP est d’implémenter en OCaml un interpréteur Magistack (https://esolangs.org/wiki/MagiStack), une machine virtuelle minimale à pile. Il y a plusieurs façons de proposer une solution, mais nous allons nous concentrer sur une en particulier.","tags":null,"title":"","type":"courses"},{"authors":null,"categories":null,"content":"Rappel Tout les TPs sont à faire sur UN SEUL repo gitlab. Avant toutes choses, créez un dépôt et ajoutez Anne Etien et Vincent Aranega comme dévelopeurs à votre dépôt. Vous pouvez travaillez en binôme, mais gardez en tête qu’un des TPs sera noté et à faire en temps limité pendant la séance de TP, donc soyez tous à l’aise avec la façon de travailler et surtout, créez bien tous un dépôt pour vous.\n   Pré-requis Dans ce premier TP, vous allez créer des méta-modèles manuellement en utilisant les outils proposés dans Eclipse. Installer les outils de modélisation directement dans une instance d’Eclipse est quelque chose de pénible. Heureusement, il existe des \u0026#34;saveurs\u0026#34; d’Eclipse spéciales avec les outils déjà pré-installés. Dans notre cas, nous allons utiliser la version \u0026#34;Eclipse Modeling Tools\u0026#34;.\n  Téléchargez \u0026#34;Eclipse Modeling Tools\u0026#34; à l’adresse suivante: https://www.eclipse.org/downloads/packages/ et décompressez le (il faut vraiment aller chercher la \u0026#34;flavour\u0026#34; modeling sur la page).\n     Modélisation du méta-modèle de Java simplifié Dans un premier temps, vous allez modéliser le méta-modèle de Java simplfié que nous avons vu en cours.\n  Assurez-vous que vous avez bien tous les concepts et re-modélisez les sur papier si nécessaire.\n  Une fois Eclipse ouvert, créez un \u0026#34;Ecore Modeling Project\u0026#34; (File→new→Others) et nommez-le simplejava.\n   Vous pouvez remarquez que toute une hiérachie de répertoire et de \u0026#34;configuration\u0026#34; est automatiquement créée. Le projet créé est automatiquement paramétré avec les différentes dépendances nécessaires pour le bon fonctionnement de votre projet de méta-modélisation. Pour l’instant, vous allez uniquement travailler dans le répertoire model généré. Il contient trois fichiers, un .aird, un .ecore et un .genmodel.\n   Le .aird est le fichier avec la représentation graphique de votre méta-modèle.\n  Le .ecore est le fichier contenant la définition de votre méta-modèle.\n  Le .genmodel est le fichier qui servira plus tard à générer le code de votre méta-modèle.\n   Pour ce TP, vous allez uniquement travailler avec le .aird, mais vous allez d’abord vérifier certaines informations sur le .ecore.\n  Déroulez dans l’arbre le .ecore et cliquez sur le package simplejava et vérifiez dans l’onglet Default de la fenêtre Properties que toutes les informations sont bien remplies (préfix, URI et nom). Si elles ne le sont pas, remplissez les en utilisant simplejava comme nom et préfix et http://simplejava/1.0 comme URI.\n  Ouvrez maintenant le fichier de représentation graphique de votre méta-modèle et modélisez le méta-modèle de Java simplifié (pour modifiez des informations d’élements, vous pouvez le faire dans l’onglet Semantic de la fenêtre de propriétés). Pensez bien à prefixer tout vos concepts par un J (par ex: JClass pour Class), pour éviter qu’il y ait des clash de noms par la suite lors de la génération de code Java et/ou Python (dans les prochains TPs).\n  Une fois terminé, ouvrez le .ecore (l’éditeur réfléxif générique devrait s’ouvrir) et vérifiez que tous les concepts sont bien présents.\n  De manière générale, il est important que vous validiez bien votre .ecore. L’opération de validation va bien vérifier que les informations que vous avez entrée dans votre méta-modèle sont bonnes (pas d’espaces en trop, de caractères non autorisés,…​etc). Si vous ne le faites pas et que des erreurs se sont glissée dans votre méta-modèle, il y a de très fortes chances que les opérations suivantes s’appuyant sur votre méta-modèle (création d’instances, génération de code,…​) vous retourne une erreur incompréhensible. Pour bien valider le méta-modèle, une fois que vous l’avez ouvert avec l’éditeur réflexif, faites un clic-droit sur la racine de votre méta-modèle (le EPackage) et choisissez validate. Si des problèmes sont relevés, ils sont indiqués et des labels sur les objets problématiques apparaissent dans l’éditeur réflexif. Corrigez les et revalidez votre modèle jusqu’à ce que le validateur vous assure que tout va bien. Attention, le fait que votre méta-modèle valide n’indique pas que votre méta-modèle représente correctement les concepts, cela veut juste dire que votre méta-modèle respecte bien le méta-méta-modèle et qu’aucune information entrée ne devrait poser problème par la suite.\n   Maintenant que votre méta-modèle est créé, pour vérifier que tout \u0026#34;est bon\u0026#34; dans votre méta-modèle, vous allez créer plusieurs modèles conformes. Pour créer des méta-modèles dynamiquement, sans générer de code, vous allez devoir choisir depuis la vue arborescente de votre ecore le concept qui représente la \u0026#34;racine\u0026#34; de votre modèle. Dans un modèle, il faut toujours considérer un conteneur principal qui est le conteneur de tous les éléments de votre modèle (ici, des packages java par exemple).\n  Ouvrez la vue arborescente et sélectionnez votre concept racine, puis faites un clic-droit sur l’élément, puis Create dynamique instances…​. Cela va vous créer un fichier .xmi.\n  Ouvrez le fichier .xmi il devrait s’ouvrir avec l’éditeur générique réflexif (le même que lorsque vous ouvrez directement le .ecore).\n  Créez un premier modèle avec quelques packages et classes.\n  Créez maintenant un autre modèle (clic-droit…​etc) et modélisez un autre modèle conforme au méta-modèle de java simplifié.\n     Modélisation du méta-modèle de système de fichier Pour cet exercice, vous allez créer un nouveau \u0026#34;Ecore Modeling Project\u0026#34; avec le nom \u0026#34;metamodels\u0026#34;. Ce projet servira à mettre tout vos autres méta-modèles (pas uniquement le java simplifié).\n  Créez le nouveau projet\n  Dans le répertoire models, créez un nouveau méta-modèle ecore: File→new→Others→Ecore Model nommé filesystem.ecore, puis ouvez le dans l’éditeur arborescent, sélectionnez le package à l’intérieur, faites clic-droit et New representation→Class Diagram. Cela crée une représentation graphique, mais ne crée pas pour autant de fichier .aird spécial.\n  En cliquant sur le package de votre méta-modèle, entrez les informations suivantes pour le nom, préfix et URI: filesystem, filesystem et http://filesystem/1.0. Vous pouvez rentrer n’importe quel nom et préfix, mais il est toujours mieux d’avoir les mêmes et d’avoir le nom apparaissant dans l’URI (qui, de préférence doit avoir la tête d’une URL).\n  Modélisez votre méta-modèle de système de fichier.\n  Modélisez ensuite quelques modèles instances de ce méta-modèle.\n     Modélisation du méta-modèle de base de données Vous suivrez les mêmes étapes que pour le méta-modèle précédent, créez le dans votre projet metamodels.\n   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"0536448eb28ae3e4e1f3bcddbf14c83c","permalink":"/courses/metamodelisation/tp1/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/metamodelisation/tp1/","section":"courses","summary":"Rappel Tout les TPs sont à faire sur UN SEUL repo gitlab. Avant toutes choses, créez un dépôt et ajoutez Anne Etien et Vincent Aranega comme dévelopeurs à votre dépôt. Vous pouvez travaillez en binôme, mais gardez en tête qu’un des TPs sera noté et à faire en temps limité pendant la séance de TP, donc soyez tous à l’aise avec la façon de travailler et surtout, créez bien tous un dépôt pour vous.","tags":null,"title":"","type":"courses"},{"authors":null,"categories":null,"content":"Notes À partir de ce TP, vous allez devoir manipuler les modèles de façon programmatique. Cela va forcément impliquer l’utilisation d’un langage de programmation pour lequel il existe le support de librairies de méta-modélisation. Vous avez le choix entre Java et Python.\n   Si vous décidez d’utiliser Java, vous devez travailler sous Eclipse, vous ne pouvez pas utiliser Intellij, les outils EMFs ne sont disponibles que sous Eclipse.\n  Si vous décidez d’utiliser Python, vous pouvez utiliser l’éditeur de code que vous préférez, mais il est indispensable d’utiliser un env. virtuel pour installer les dépendances sans altérer votre système.\n   Comme ce TP est une prise en main des différentes librairies, des détails seront donnés pour les deux langages et les différents outils. Par contre, il est important que : * soit vous décidiez de tester les deux librairies au fil des TPs et alors, d’être bien attentif et de faire attention à la manière de manipuler les choses, * soit vous décidiez de rester avec un seul langage/lib pour éviter de multiplier la complexité, dans ce cas, jetez quand-même un oeil à comment les choses sont manipulées chez un de vos camarades pour bien voir les similitudes et différences techniques.\n À vérifier : à plusieurs étapes, du code va être généré, soit en Java, soit en Python. Faîtes bien attention au nommage de vos méta-classes dans votre méta-modèle. Si vous utilisez des noms réservés ou des noms spéciaux, il est possible que cela pose problème une fois que le code sera généré. Spécialement, faites attention aux noms de méta-classes/attributs/references qui porteraient des nom comme class (avec une minuscule), super (qui clasherait en Python), return (qui pourrait poser problème en Java et Python),…​etc Tout ces noms ne vont pas poser systématiquement problème, mais si vous vous retrouvez avec un modèle qui ne se charge pas pour une raison obscure, essayez de vérifier qu’il n’y a pas de soucis de nommage.\n Aussi, prêtez une attention toute particulière à l\u0026#39;`URI` de vos méta-modèles. Si vous avez un modèle qui ne se charge pas bien et que vous ne comprenez pas pourquoi, vérifiez que votre modèle au format .xmi fait bien référence au même prefix et URI que ceux écrit pour votre méta-modèle (pour votre EPackage racine).\n   Manipulation d’instances Vous allez manipuler ici les méta-modèles que vous avez définis au TP précédent, c’est-à-dire simplejava, filesystem et votre méta-modèle de base de donnée. Pour pouvoir manipuler des modèles, il faut être en mesure de charger le méta-modèle dont ils sont instances depuis un fichier .ecore. Pour charger un fichier, EMF/PyEcore passent par un système de Resource. Une Resource représente une entité logique qui contient un modèle ou un méta-modèle depuis une source en particulier (ici depuis un fichier). Ces resources sont conservées dans un ResourceSet, qui représente un conteneur de resources. Le ResourceSet fait plus qu’uniquement conserver des resources par ce qu’il va aussi permettre de lier des factories spéciales pour lire des formats de fichiers spécifiques et pour enregistrer des méta-modèles existants. Enregistrer un méta-modèle dans un ResourceSet signifie que ce ResourceSet est en mesure de lire des instances de ce méta-modèle.\n Directement, à partir de code généré La génération du code d’un méta-modèle repose sur le fait de générer le code Java ou Python des méta-classes décrites dans le méta-modèle. Comme les librairies de méta-modélisation sont légèrement différentes, la génération de code ne se passe pas de la même manière.\n En Java avec EMF La génération de code passe par un .genmodel qui est un fichier de configuration de la génération de code. Pour le méta-modèle simple java, le .genmodel devrait être déjà existant, vous pouvez donc le réutiliser.\n  Ouvrez le fichier .genmodel et faites clic-droit sur la racine du fichier ouvert, puis Generate Model Code\n   Si vous n’avez pas de .genmodel pour votre méta-modèle\n  Faites un clic-droit sur votre .ecore, puis new→Other→EMF Generator Model, suivez les étapes pour générer le .genmodel\n  Ouvrez ensuite le fichier généré et faites clic-droit sur la racine du fichier ouvert, puis Generate Model Code\n   À l’issue de ces étapes, vous devriez avoir le code de votre méta-modèle entièrement généré. Maintenant, pour pouvoir ouvrir des modèles existant, il est nécessaire d’enregistrer une dépendance en plus pour votre projet \u0026#34;Ecore Modeling Project\u0026#34;.\n  Ouvrez le fichier META-INF/MANIFEST.MF, puis switchez sur l’onglet Dependencies\n  À partir de cet onglet, cliquez sur le Add…​ de la frame de gauche Required plug-ins et ajoutez le plugin suivant :\n  org.eclipse.emf.ecore.xmi\n      Vous pouvez maintenant charger un modèle instance du méta-modèle enregistré comme vue précédemment en utilisant le ResourceSet correctement paramétré.\n le méta-modèle que vous voulez utiliser dans un ResourceSet. Cela se fait avec le code ci-dessous. Notez bien que ce snippet créer en premier lieux un ResourceSet et le configure ensuite en enregistrant les méta-modèles dont il aura besoin pour lire votre modèle. Pour chaque nouveau méta-modèle dont vous générez le code, vous devez aussi l’enregistrer dans le ResourceSet.\n ResourceSet rset = new ResourceSetImpl(); rset.getResourceFactoryRegistry().getExtensionToFactoryMap().put(\u0026#34;ecore\u0026#34;, new XMIResourceFactoryImpl()); rset.getResourceFactoryRegistry().getExtensionToFactoryMap().put(\u0026#34;xmi\u0026#34;, new XMIResourceFactoryImpl()); rset.getPackageRegistry().put(SimplejavaPackage.eNS_URI, SimplejavaPackage.eINSTANCE); Resource resource = rset.getResource(URI.createFileURI(\u0026#34;path_vers_un_modele\u0026#34;), true); JavaModel model = (JavaModel) resource.getContents().get(0); // JavaModel est le nom du concept racine du méta-modèle simple java, // chez vous il peut avoir un nom différent ! Pensez bien à le modifier !    En Python avec PyEcore La génération de code avec PyEcore passe par pyecoregen un outil dédié utilisant PyEcore pour générer le code Python des concepts du méta-modèle. Dans un premier temps, créez un env. virtuel :\n  placez-vous dans votre répertoire de travail (celui de votre repository) et tapez la commande suivante : $ virtualenv venv. Cela va créer un environnement virtuel dans le répertoire venv que vous pourrez activez quand vous voulez. Si la commande virtualenv n’est pas connue directement, utilisez à la place $ python3 -m venv venv, cela va créer un environnement virtuel venv, exactement comme la première commande.\n  Avant d’activer votre environnement virtuel, ajoutez le répertoire venv à votre .gitignore pour ne pas le commiter\n  Activez votre environnement virtuel de la manière suivante : source venv/bin/activate. Attention Si vous êtes sous windows, pour activer l’environnement virtuel, il est possible que la commande soit différente et qu’il faille aller chercher le venv\\bin\\activate.bat, si vous utilisez le sous-système linux sous windows, ça devrait être la même chose.\n   Vous pouvez maintenant installer les dépendances qui vous seront utiles :\n  Installez pyecoregen, dans votre virtualenv, tapez pip install pyecoregen\n  Générez le code de votre méta-modèle, ceci se fait avec la commande pyecoregen -e chemin_vers_ecore -o . (il s’agit bien d’un . en fin de ligne). Cette commande génère le code de votre méta-modèle dans le répertoire courant.\n   Maintenant que le code de votre méta-modèle est généré, il est possible de l’utiliser et d’ouvrir un modèle existant : Dans un premier temps, enregistrez le métamodèle dans un ResourceSet comme ceci :\n from pyecore.resources import ResourceSet import simplejava # pour le méta-modèle simplejava  rset = ResourceSet() rset.metamodel_registry[simplejava.nsURI] = simplejava # enregistre le méta-modèle simplejava # si vous générez le code d\u0026#39;autres méta-modèles, n\u0026#39;oubliez pas de les enregistrer aussi resource = rset.get_resource(\u0026#39;path_vers_un_modele_simplejava\u0026#39;) racine = resource.contents[0]    Questions générales Voilà quelques questions relatives à simple java :\n  Écrivez une fonction qui prend en paramètre l’équivalent d’un JavaModel et qui retourne la liste de toutes les classes d’un de vos modèles simplejava (toutes les classes qui ont été modélisées dans le modèle, donc toute les instances de JClass si vous les avez nommé comme ça). Testez votre fonction avec plusieurs modèles. Si vous êtes certains qu’un de vos collègues à exactement le même méta-modèle que vous (mêmes nommage, relations, URI, prefix…​etc), vous pouvez échanger des modèles pour vérifier que tout fonctionne correctement.\n  Écrivez une fonction qui affiche à l’écran le nom de tous les attributs (equivalent JAttribute contenues par les JClass) de votre modèle java.\n  Écrivez une fonction qui retourne la profondeur d’héritage d’une JCLass classe en particulier (par exemple, en considérant que l’on a une instance de class JObject nommé Object dans notre méta-modèle, 0 sera retourné pour cette instance de JClass, 1 pour les classes qui héritent de Object, 2 pour les classes qui héritent des précédentes et ainsi de suite)\n  Écrivez une fonction qui retourne le nom pleinement qualifié d’une instance de JClass (le nom de tous ses packages contenant séparés par un . suivi du nom de la classe)\n   Voilà quelques questions relatives à filesystem :\n  Écrivez une fonction qui retourne le nombre de fichiers de votre modèle\n  Écrivez une fonction qui retourne le poids de tous les fichiers contenus dans un répertoire\n  Écrivez une fonction qui retourne le poids de tous les fichiers contenus dans le modèle\n   Et quelques questions pour la manipulation directe de vos méta-modèles :\n  Écrivez une fonction qui prend un EPackage en paramètre et retourne le nombre de méta-classes d’un de vos méta-modèles\n  Écrivez une fonction qui prend une EClass en paramètre et retourne les méta-classes qui héritent d’elle dans votre méta-modèle.\n     Réflexivement, sans code généré En Java avec EMF La première étape pour pouvoir créer des modèles relatifs à un méta-modèle, il vous faut charger en mémoire un méta-modèle existant à partir d’un fichier .ecore. Voilà le fragment de code que vous pouvez utiliser pour charger un modèle ecore/xmi directement en Java :\n ResourceSet rset = new ResourceSetImpl(); rset.getResourceFactoryRegistry().getExtensionToFactoryMap()* .put(\u0026#34;ecore\u0026#34;, new XMIResourceFactoryImpl()); rset.getResourceFactoryRegistry().getExtensionToFactoryMap()* .put(\u0026#34;xmi\u0026#34;, new XMIResourceFactoryImpl()); Resource resource = rset.getResource(URI.createFileURI(\u0026#34;path_vers_ecore\u0026#34;), true); // À partir de là \u0026#34;pack\u0026#34; contient le EPackage de votre méta-modèle EPackage pack = (EPackage) resource.getContents().get(0); // Puis pour l\u0026#39;enregistrer rset.getPackageRegistry().put(pack.getNsURI(), pack);   Contrairement au snipet Java précédent, vous pouvez noter que cette fois, le code du méta-modèle n’est pas généré, on vient charger le méta-modèle à partir d’un fichier (on le charge en mémoire) et qu’ensuite, on enregistre cette représentation mémoire dans le ResourceSet. Vous pouvez maintenant charger un modèle instance du méta-modèle enregistré comme vue précédemment en utilisant ce ResourceSet correctement paramétré.\n  En Python avec PyEcore L’ouverture d’un modèle .ecore via PyEcore se fait de plusieurs façons, mais la façon la plus simple est d’utiliser un ResourceSet :\n from pyecore.resources import ResourceSet rset = ResourceSet() resource = rset.get_resource(\u0026#39;path_vers_ecore\u0026#39;) pack = resource.contents[0] rset.metamodel_registry[pack.nsURI] = pack   Contrairement au snipet Python précédent, vous pouvez noter que cette fois, le code du méta-modèle n’est pas généré, on vient charger le méta-modèle à partir d’un fichier (on le charge en mémoire) et qu’ensuite, on enregistre cette représentation mémoire dans le ResourceSet. Vous pouvez maintenant charger un modèle instance du méta-modèle enregistré comme vue précédemment en utilisant ce ResourceSet correctement paramétré.\n     Création, modification de modèles Une fois que votre méta-modèle est chargé en mémoire à partir de son .ecore, vous allez l’utiliser pour créer des petits modèles dans les questions suivantes.\n  Écrivez une fonction qui prend en paramètre le nom d’une des méta-classes de votre méta-modèle et qui retourne la méta-classe associée ou null si la méta-classe n’existe pas.\n  Écrivez une fonction qui permet de créer une instance d’un méta-classe dont le EPackage et le nom de la méta-classe serait passé en paramètre.\n  Écrivez une fonction qui prend un EObject quelconque, une chaine de caractère et qui initialise l’équivalent du nom de l\u0026#39;`EObject` à la valeur passée en paramètre si l’objet en question possède un attribut name.\n  Testez votre solution avec des instances de votre méta-modèle java, votre méta-modèle de système de fichier et votre méta-modèle de BD. Pour faire ceci :\n chargez les trois EPackage de chaque méta-modèles depuis leur .ecore dans des variables sjava, fsystem et bd en utilisant le code fournit plus haut relatif à votre langage (celui pour charger un métamodèle depuis un .ecore).\n  créez une instance d’un des concepts de vos métamodèles en utilisant votre fonction de création à partir d’un nom de méta-classe\n  initialisez le nom des instances que vous avez créé avec une valeur\n  recherchez reflexivement la valeur du name de votre objet pour vérifier que la valeur a bien été initialisé pour l’attribut.\n      Autre utilisation de la couche réflexive Dans cette partie du TP, vous allez utilisez plus en détail la couche réflexive pour commencer à prendre plus d’aisance avec la manipulation du méta-niveau.\n  Écrivez une fonction qui prend un EObject quelconque et qui affiche à l’écran le nom de chacun de ses attributs/références ainsi que la valeur de chacun des attributs/références.\n  Écrivez une fonction qui recherche dans un objet le premier attribut de type chaîne de caractère (type EString) et qui le modifie pour que le nom devienne id_VALEURAVANT (ex : pour egg stocké dans l’attribut nom, la nouvelle chaîne attribué à nom sera id_egg).\n      ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"0829a14bc1aa47d3be55418699e04299","permalink":"/courses/metamodelisation/tp2/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/metamodelisation/tp2/","section":"courses","summary":"Notes À partir de ce TP, vous allez devoir manipuler les modèles de façon programmatique. Cela va forcément impliquer l’utilisation d’un langage de programmation pour lequel il existe le support de librairies de méta-modélisation.","tags":null,"title":"","type":"courses"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"9fbb3dbdd47e38edcad22d650dfeee27","permalink":"/courses/metamodelisation/tp3/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/metamodelisation/tp3/","section":"courses","summary":"","tags":null,"title":"","type":"courses"},{"authors":null,"categories":null,"content":"Note Dans ce TP vous allez coder un algorithme de sérialisation à plat. Comme pour les précédents TPs, vous avez le choix entre Java et Python. De manière générale, pour simplifier le parsing, nous allons sérialiser les modèles en JSON selon un schéma de votre choix. Regardez comment produire et lire du JSON en Java. En Python, tout est intégré dans la bibliothèque standard, mais en Java, il faudra que vous utilisiez une bibliothèque externe. Regardez celles qui existent et choisissez celle que vous préférez.\n Au TP2, vous avez vu comment lire toutes les informations d’un objet de manière réflexive, cette étape est primordiale pour pouvoir écrire l’algorithme de sérialisation.\n   Format des données et méta-information La manière dont vous choisissez de sauvegarder les données dépend de vous (pour ce TP, même si vous allez tous produire plus ou moins la même chose), néanmoins, dès que vous allez devoir faire référence à des méta-classes et aux objets en interne, il est important que vous gardiez le même format.\n Deux méta-informations vont devoir être conservées lorsque le modèle est sérialisé. Ces informations sont nécessaires pour indiquer certaines choses sur les données, mais elle ne fait pas directement partie de l’objet. On parle donc de méta-information, elle est utile, mais pas directement comprise dans les objets. Ici, deux méta-informations vont être nécessaires :\n   un identifiant unique qui sera donné à chaque objet afin de pouvoir le référencer dans le modèle,\n  une référence vers la méta-classe de l’objet.\n   Concernant l’identifiant, un simple numéro sera suffisant pour référencer les informations à travers le fichier.\n Pour la référence à la méta-classe, plutôt que, comme dans XMI, donner juste le nom de la méta-classe et faire référence à un préfix représentant une référence indirecte vers l’URI du méta-modèle dans lequel se trouve la méta-classe en question, vous allez utiliser le format suivant : URI_DU_MM#NOM_DE_LA_MC. Si on prend l’exemple de java simplifié, il serait possible de sérialiser un simple objet classe en JSON de la manière suivante :\n {\u0026#34;#id\u0026#34;:1,\u0026#34;#metaclass\u0026#34;:\u0026#34;http://simplejava/1.0#JavaClass\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;MyClass\u0026#34;,}   Sur cette exemple, les champs débutant par un # représentent des méta-informations. Le champ #metaclass donne à la fois l’URI du méta-modèle d’où provient la méta-classe et le nom de la méta-classe en elle-même. Le champ #id donne un numéro unique pour l’objet qui est sérialisé.\n   Sérialisation \u0026#34;à plat\u0026#34; Comme nous l’avons vu en cours, la sérialisation à plat repose sur le fait que tous les éléments sont \u0026#34;à plat\u0026#34;, c’est-à-dire qu’ils sont tous sauvegardés de manière textuelle dans l’équivalent d’une grande liste.\n Pour écrire la sérialisation, voilà les questions que vous devez vous poser :\n  Quelles informations dois-je sauvegarder ?\n  Dois-je traiter les attributs et références de manières différentes ?\n  Comment dois-je gérer les relations many ? Et les relations \u0026#34;opposites\u0026#34; ?\n  Comment dois-je faire référence à un objet au sein du fichier ?\n  Est-il possible d’éviter de sauvegarder certaines informations ?\n     S’il vous reste du temps Vous pouvez essayer d’écrire un algorithme de désérialisation. Ces algos sont beaucoup moins triviaux à écrire que ceux de la sérialisation comme il faut à la fois lire les données du fichier et lier chaque élément lu avec une méta-classe afin d’en créer une instance.\n  Quelle information du fichier sérialisé va donner l’indication sur le méta-modèle à utiliser ? À partir de quel objet peut-on trouver le méta-modèle correspondant ?\n  Écrivez une classe qui va représenter le désérialiseur.\n Écrivez une fonction qui, étant donné cette information est capable de retrouver le méta-modèle à utiliser.\n  Écrivez une fonction qui, étant donné un nom de méta-classe est capable de retrouver la méta-classe depuis le méta-modèle\n  Écrivez une fonction qui est capable de créer une instance de cette méta-classe, de lire les informations de l’objet depuis le fichier\n        ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"69c83abd2d386a1e0c43191782b4af4e","permalink":"/courses/metamodelisation/tp4/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/metamodelisation/tp4/","section":"courses","summary":"Note Dans ce TP vous allez coder un algorithme de sérialisation à plat. Comme pour les précédents TPs, vous avez le choix entre Java et Python. De manière générale, pour simplifier le parsing, nous allons sérialiser les modèles en JSON selon un schéma de votre choix.","tags":null,"title":"","type":"courses"},{"authors":null,"categories":null,"content":"Note et pré-requis Le but de ce TP va être de produire plusieurs petites transformations de modèles, basées sur les méta-modèles que vous avez pu développer ainsi qu’un moteur de chaînes de transformations MDE-based.\n Ce TP, un peu plus long que les autres, est à faire en utilisant Python, pour des raisons techniques. Les moteurs de transformations de modèles utilisant les technologies EMF-Java (ex: ATL, QVTo, Epsilon, Acceleo), sont bien établies et fonctionnent très bien lorsqu’on les utilise de manière localisées, mais leur usage est parfois très lourd : configurations complexes, interfaçage avec divers moteurs complexes, chaînage de transformations complexes à mettre en oeuvre et usage en dehors d’Eclipse vraiment compliqué et pénible.\n  Pré-requis  Si vous n’avez pas travaillé en Python en premier lieux, assurez-vous d’avoir bien les méta-modèles au format .ecore pour ce TP, il faudra générer les méta-modèle PyEcore à partir d’eux. Aussi, créez un virtualenv dédié pour ce TPs (environnement virtuel Python pour installer des dépendances sans bouleverser votre système).\n     Génération du code des méta-modèles Si vous avez le code des méta-modèles déjà générés en Python, vous pouvez sauter cette étape et passer directement à la prochaine section.\n Si vous n’avez pas le code des méta-modèles en Python, il est nécessaire de les générer. Pour faire ça, dans un premier temps, il est intéressant de créer un environnement virtuel. Pour créer un environnement virtuel :\n  placez-vous dans votre répertoire de travail (celui de votre repository) et tapez la commande suivante : $ virtualenv venv. Cela va créer un environnement virtuel dans le répertoire venv que vous pourrez activez quand vous voulez.\n  Avant d’activer votre environnement virtuel, ajoutez le répertoire venv à votre .gitignore pour ne pas le commiter\n  Activez votre environnement virtuel de la manière suivante : source venv/bin/activate\n   Vous pouvez maintenant installer les outils nécessaires pour méta-modéliser et travailler avec Ecore de la manière suivante : $ pip install pyecore pyecoregen.\n   Transformations de modèles avec Motra L’année passée vous avez manipulé des transformations de modèles type ATL ou, très certainement, QVTo. Ces langages de transformations reposent sur OCL pour la navigation dans les modèles et rajoutent des concepts pour la création/modification/suppression d’éléments dans les modèles manipulés. Dans ce TP, vous allez utiliser un nouveau type de langage qui n’est pas, comme ATL, QVT…​ un DSL externe, mais un DSL interne à Python nommé Motra (pour MOdel TRAnsformation). Ce DSL repose entièrement sur Python en étendant, d’une certaine manière, le langage et en proposant une sémantique proche de QVTo. Motra est toujours considéré comme expérimental, donc si vous trouvez des soucis, n’hésitez pas à nous les remonter directement ou à écrire une issue détaillée sur github.\n  Activez votre virtualenv et installez la librairie : $ pip install motra\n  Regardez les quelques exemples donnés directement sur le repository : https://github.com/pyecore/motra/tree/main/examples/m2m\n   Vous allez maintenant écrire plusieurs petites transformations qui seront des transformations \u0026#34;sur-place\u0026#34; et \u0026#34;exogènes\u0026#34;.\n Transformation sur votre meta-modèle de BD  Écrivez une transformation qui transforme le nom de toutes les tables de camel case vers snake case majuscule (ex: MyTable deviendra MY_TABLE).\n  Écrivez\n    Transformations sur simplejava  Écrivez une transformation qui ajoute un attribut id de type String pour chaque objets. Attention à n’introduire l’attribut que pour les classes qui n’héritent d’aucune autre. S’il existe déjà dans la classe un attribut qui commence par id_ ou qui s’appelle id, alors la transformation n’ajoutera pas de nouveau l’élément.\n  Écrivez une transformation qui introduit une interface commune possédant une méthode getUUID() à tout les objets. Attention à n’introduire l’interface que pour les classes qui n’héritent d’aucune autre.\n  Écrivez une transformation qui détecte les hiérarchies de classes (arbres d’héritages) et qui rajoute au modèle l’équivalent d’une factory, c’est-à-dire, une classe qui possède une méthode pour créer une instance de chaque classe non abstraite de l’arbre d’héritage découvert.\n    Transformation de simplejava vers votre méta-modèle de BD Vous allez maintenant écrire une transformation qui permet de passer d’un modèle simple Java vers un modèle de base de donnée. Voilà les questions à vous poser :\n   Quels sont les éléments à traduire ?\n  Quelle va être la traduction d’une classe ?\n  Quelle va être la traduction d’un attribut ?\n  Comment gérer l’héritage ?\n  Comment déterminer une clef primaire depuis une classe Java ?\n   Puis, une fois que vous avez des réponses plutôt précises à ces questions :\n  Écrivez la transformation pour passer d’un modèle Java à un modèle de base de données.\n    Transformation de simplejava vers votre méta-modèle de système de fichiers Comme précédemment, les mêmes questions se posent :\n   Quels sont les éléments à traduire ?\n  Quelle va être la traduction d’un package ?\n  Quelle va être la traduction d’une classe ?\n   Puis, une fois que vous avez des réponses plutôt précises à ces questions :\n  Écrivez la transformation pour passer d’un modèle Java à un modèle de système de fichiers.\n      Un moteur de chaîne de transformations Vous allez développer ici un moteur de chaîne de transformations et expérimenter avec les transformations que vous avez écrites avant. Pour modéliser le moteur de chaîne, vous allez modéliser dans un premier temps un méta-modèle Ecore de chaîne de transformations.\n Une chaîne simplifiée de transformations Une chaîne de transformations est composée de plusieurs opérations. Ces opérations peuvent être des transformations de modèles (M2M et M2T) ou une opération de sauvegarde de modèle vers un chemin en particulier. Chaque opération possède une relation vers la chaîne qui la contient. Chaque opération possède une méthode execute qui prend exactement un paramètre, le modèle sur lequel va s’appliquer l’opération et qui retourne le nouveau modèle. Chaque transformation est liée à une transformation Motra (modélisée par un attribut vers un EJavaObject qui sera traduit vers une relation vers un objet Python natif lors de la génération). Finalement, la chaîne en elle-même possède une méthode run qui prend en paramètre un chemin vers un fichier et qui retourne le résultat de la dernière opération exécutée.\n  Modélisez le méta-modèle de chaîne de transformations au format Ecore en utilisant le \u0026#34;ecore diagram tool\u0026#34; sous Eclipse. Pour simplifier les prochaines opérations, utilisez ces valeurs pour le package racine de votre méta-modèle : name=chainengine, nsPrefix=chainengine, nsURI=http://chainengine/1.0\n  Une fois que vous avez modélisé votre méta-modèle de chaîne, utilisez la ligne suivante pour générer le code du méta-modèle : $ pyecoregen -e votre_metamodel.ecore -o . --user-module chainengine.mixins\n  Copiez le fichier de mixins généré avec cette commande : $ cp chainengine/chainengine_mixins.py.skeleton chainengine/mixins.py. Vous allez écrire le code des méthodes execute et run directement dans ce fichier chainengine/mixins.py, cela évitera, si vous générez plusieurs fois le code de votre méta-modèle, d’écraser le code que vous avez écrit.\n   Voici un exemple de comment vous pouvez décrire maintenant une chaîne de transformations (pour un méta-modèle, si vous avez modélisé les choses autrement, vous aurez un autre code) :\n from chainengine import * from transfos import t1, t2, t3 # on suppose plusieurs transformations  chain = Chain(name=\u0026#34;first_chain\u0026#34;) chain.operations.append(M2M(transformation=t1)) chain.operations.append(M2M(transformation=t2)) chain.operations.append(SaveModel(path=\u0026#39;intermediaire.xmi\u0026#39;)) chain.operations.append(M2M(transformation=t1)) chain.operations.append(M2M(transformation=t3)) chain.operations.append(SaveModel(path=\u0026#39;final.xmi\u0026#39;))) chain.run(\u0026#39;mon_modele.xmi\u0026#39;)   Actuellement, si vous exécutez ce code, vous allez récupérer une exception vous disant que votre code pour les méthodes run et execute ne sont pas encore implémentées. C’est ce que vous allez faire maintenant, mais avant ça, il est nécessaire de comprendre un peu comment Motra lance les transformations, ce qu’il attend en paramètre et ce qu’il retourne.\n Motra, paramètre d’entrée, de sorties et un ResourceSet unique Lorsque vous avez codé une transformation avec Motra, vous pouvez la lancer de la manière suivante :\n from pyecore.resources import ResourceSet from matransfo import t # import de la transformation  # En considérant que \u0026#34;t\u0026#34; est définie comme t [in_model, out_model] rset = ResourceSet() result = t.run(in_model=\u0026#39;path_to_model.xmi\u0026#39;, resource_set=rset)   Il est important de noter que pour lancer la transformation, le nom du modèle d’entrée spécifié lors de la transformation doit-être utilisé. Il faut aussi noter que tout au long de la transformation, il faudra gérer une même instance de ResourceSet.\n  Au début de la méthode run de votre chaîne, ajouter un attribut d’instance resource_set initialisé avec une nouvelle instance de ResourceSet. Cette instance pourra être récupérée par toutes les opérations si elles en ont besoin.\n  À la fin de la méthode run de votre chaîne, affectez la valeur None à votre attribut d’instance resource_set. Cela marque le fait qu’une fois que l’exécution de la chaine est terminée, cet attribut n’a plus de raison d’avoir une valeur non-nulle.\n   Vous allez coder maintenant les méthodes execute pour chacune des opérations.\n  Écrivez la méthode execute de l’opération de sauvegarde de modèle. Pour rappel, cette méthode reçoit en paramètre la resource représentant le modèle qui doit être sauvegardé, doit sauvegarder le modèle (en utilisant la méthode save(output=…​) de la resource), puis retourner la resource passée en paramètre.\n  Écrivez la méthode execute de l’opération d’exécution d’une transformation de modèle. Cette méthode doit :\n prendre en paramètre un modèle,\n  demander à la transformation le nom de son paramètre d’entrée (récupérable par en utilisant le premier élément de la collection input_defs[0]),\n  construire un dictionnaire avec comme clé le nom du paramètre d’entrée et en valeur associé le paramètre d’entrée de la méthode,\n  récupérer le ResourceSet de la chaîne,\n  exécuter la transformation associé à l’opération avec en paramètre, le resource set récupéré et le dictionnaire que vous avez construit expand avec l’opérateur **. Cela signifie que si votre dictionnaire s’appelle input_dict et votre resource set stocké dans une variable rset, les paramètres passés à l’appel devront être (resource_set=rset, **input_dict),\n  récupérer le résultat de l’exécution\n  retourner le premier modèle de sortie de la transformation, récupérable via l’attribut outputs[0] du résultat de l’exécution\n      À l’issue de ces 2 méthodes, vous avez presque fini l’écriture de votre moteur de chaîne, il ne vous reste plus qu’à coder le corps de la fonction qui va vous servir à lancer le tout.\n  Écrivez la méthode run de votre chaîne. Cette méthode va tout simplement itérer sur toutes les opérations de votre chaîne et passer le résultat de chaque appels comme paramètre de la prochaine opération.\n  Utilisez votre moteur de chaîne pour décrire plusieurs chaînes de transformations en composant avec les transformations que vous avez codé précédemment, ou en utilisant les transformations codées par vos camarade, si vous êtes certains que vous avez des méta-modèles compatibles\n     Vers une fluent-API pour la création de chaînes Avec votre moteur de chaînes, vous êtes en mesure de créer des chaînes complexes et d’observer comment les transformations peuvent-être réutilisés et l’impact du chaînage sur les modèles. Cependant, vous pouvez remarquer que la description d’un modèle de chaînes est un peu pénible. Ici, vous allez implémenter une fluent-API qui va vous permettre de modéliser plus facilement des chaînes.\n Les fluent-API sont des APIs proposés pour simplifier l’utilisation de bibliothèques en donnant une abstraction qui permet de très facilement chaîner plusieurs appels pour écrire une \u0026#34;longue phrase\u0026#34; plutôt que plusieurs lignes. C’est, par exemple, le cas de l’API de stream de Java et, plus généralement, pour implémenter les patterns builder.\n Pour faire ceci, vous allez implémenter, dans un module Python séparé (un autre fichier Python), une classe qui servira de point d’entrée pour la création de chaînes. Vous nommerez cette classe comme vous voulez, mais voilà à quoi devrait ressembler ce que vous pourrez exprimer une fois que votre fluent-API aura été codée (ici nommé ChainBuilder):\n # Les parenthèses de début et fin ne sont là que pour pouvoir écrire le code sur # plusieurs lignes (ChainBuilder(name=\u0026#39;first_chain\u0026#39;) .m2m(t1) .m2m(t2).save(\u0026#39;intermediaire.xmi\u0026#39;) .m2m(t1) .m2m(t3).save(\u0026#39;final.xmi\u0026#39;) .run(\u0026#39;mon_modele.xmi\u0026#39;))    Écrivez une classe permettant de définir une Fluent-API pour votre moteur de chaine.\n  Utilisez votre nouvelle API pour décrire plusieurs chaines de transformations en composant avec les transformations que vous avez codé précédemment, ou en utilisant les transformations codées par vos camarade, si vous êtes certains que vous avez des méta-modèles compatibles\n      ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"1cd01ecee4154207512a8d4611764c0a","permalink":"/courses/metamodelisation/tp5/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/metamodelisation/tp5/","section":"courses","summary":"Note et pré-requis Le but de ce TP va être de produire plusieurs petites transformations de modèles, basées sur les méta-modèles que vous avez pu développer ainsi qu’un moteur de chaînes de transformations MDE-based.","tags":null,"title":"","type":"courses"},{"authors":null,"categories":null,"content":"Note Dans ce TP, vous allez mettre manipuler un type de modèle un peu différent de ceux que vous avez manipulé pendant les TPs précédent. Cette fois, vous n’utiliserez pas EMF ou PyEcore, mais vous vous allez manipuler directement le méta-modèle Java pour extraire de l’information, générer du code ou coder des fonctions utilitaires.\n   Méta-niveau en Java La manipulation du méta-niveau en Java est moins aisé qu’en Python, elle est aussi beaucoup moins permissive. Néanmoins, elle permet de faire des choses assez avancée. À travers les questions suivantes, vous allez écrire l’équivalent d’une classe qui va permettre de builder des instances d’objets quelconque, du moment que les attributs sont des attributs primitifs (chaînes de caractères, entiers, …​). Avant ça, quelques fonctions pour vous mettre un poil à l’aise avec une partie de l’API reflexive de Java.\n  Écrivez une fonction qui prend une instance et qui retourne dans une map le nom et le type de tout ses attributs d’instances.\n Écrivez une fonction qui prend une classe et qui affiche son nom, ainsi que le nom de toutes ses super-classes en suivant l’arbre d’héritage.\n  Écrivez une méthode static getAllFields() qui prend une classe en paramètre et qui retourne une liste de toute ses Field, direct et hérités (la méthode .getDeclaredFields()) ne retourne que les fields de la classe, pas de ses super-classes.\n  Écrivez une fonction qui prend un objet en paramètre et qui retourne dans une map la valeur de tout les attributs de cette instance. Pour accéder à la valeur d’un champ, il faut demander à l’instance de Field (représentant l’attribut), sa valeur sur un object en particulier en utilisant la méthode .get(Object o). Pour accéder aux champs privés d’un objet, il est nécessaire, avant d’y accéder, de changer son accéssibilité avec la méthode .setAccessible(true). Note: vous n’allez pas forcément vous servir de la fonction écrite précédemment.\n      Maintenant que vous savez manipuler un peu mieux le méta-niveau, vous allez écrire un classe spéciale Instance qui va représenter une instance. Cette classe possède 2 champs : * un champ _class de type String qui va représenter le type de l’instance, * un champ attributes de type Map\u0026lt;String, String\u0026gt; qui va représenter le dictionnaire de toutes les valeurs des instances.\n  Écrivez une telle classe\n  Écrivez une méthode statique dans votre classe Instance qui prend une instance quelconque et qui retourne une instance de votre classe Instance.\n   Maintenant que le travail est fait dans un sens (instance vers Instance), vous allez faire le travail inverse, soit prendre une instance de Instance et recréer une instance de la véritable classe qu’il représente. Dans un premier temps, vous allez écrire plusieurs méthode utilitaires.\n  Écrivez une méthode Field findField(Class\u0026lt;?\u0026gt; cls, String name) qui cherche dans la liste de tout les attributs de la classe cls le Field associé au nom name. Cette méthode lèvera l’exception NoSuchFieldException si le champ n’existe pas. Note : utilisez la méthode getAllFields que vous avez déjà codé pour vous aider.\n   Si vous avez suivit, vous savez que les valeurs des attributs sont représentés dans Instance comme des String. Il faut donc un moyen de parser ces strings en objets natif. Pour faire ceci, vous allez écrire une méthode générique qui va automatiquement appeler la bonne méthode de traduction en fonction du nom et du type de l’attribut à parser.\n  Écrivez une méthode Object parse(Field f, String s) qui prend le champ représentant l’attribut, ainsi que la chaîne de caractère représentant la valeur du champ et qui retourne la valeur native Java de l’attribut (par exemple, la méthode retournera la valeur entière 3 pour la chaîne de caractère \u0026#34;3\u0026#34; si le champ est un champ de type int ). Pour faire ceci de manière générique, vous allez suivre les étapes suivantes:\n Récupérez à l’aide de la méthode getDeclaredMethod(…​, …​) la méthode qui porte le nom parse_NOMDUTYPE ou NOMDUTYPE est remplacé par le nom du type du Field. La méthode getDeclaredMethod attend au moins 2 paramètres, le nom de la méthode, et le type des paramètres de la méthode à rechercher. Par exemple, pour un Field de type int, le nom de la méthode à chercher sera parse_int et le paramètre de la méthode uniquement un String. Pour rechercher une telle méthode, votre code ressemblera à ça : Method m = this.getClass().getDeclaredMethod(\u0026#34;parse_int\u0026#34;, String.class);\n  Une fois que vous avez la méthode, invoquez là sur votre propre instance avec la chaîne à traduire: m.invoke(this, s) et retourner la valeur.\n      Cette fonction est générique et va automatiquement rechercher la bonne fonction en fonction du type définit du champ. Cependant, pour que cette fonction marche, il est impératif de coder les méthodes associés (parse_int, parse_float, …​) dans votre classe Instance.\n  Écrivez les différentes fonctions parse_int…​etc pour les types primitifs de Java\n  Écrivez une méthode create() dans la classe Instance qui créé une véritable instance de la classe que vous avez donné comme paramètre _class de votre instance d\u0026#39;`Instance` et qui initialise tout les attributs d’instances. Note : pour trouver une véritable classe à partir de son nom, il faut passer par le ClassLoader qui est accessible via n’importe quelle classe en utilisant : .getClassLoader() puis la méthode .loadClass(…​) qui prend en paramètre la String représentant le nom de la classe. La recette à suivre est la suivante :\n Récupérez le class loader\n  À l’aide du class loader, récupérez la classe qui porte le nom du champ _class de votre Instance\n  Récupérez le premier constructeur de la classe que vous avez récupéré (.getConstructors())\n  Depuis ce constructeur, créez une instance (.newInstance())\n  Itérez sur toutes les entrées de votre table attributes et pour chaque entrée:\n Utilisez la clé de l’entrée pour récupérez le Field dans la classe que vous avez récupéré\n  Parsez la value de l’entrée\n  Indiquez que le field est accessible (.setAccessible(true))\n  Initialisez la valeur du field avec la valeur que vous avez parsé.\n         Si votre code des correct, en considérant les classes suivantes, voilà comment vous devriez pouvoir utiliser tout votre code.\n public class B { public int x; protected int y; // and accessors } public class A extends B { private float z; // and accessors } public class MyMain { public static void main(String[] args) { A a1 = new A() Instance i1 = Instance.convert(a1); A a2 = (A)i1.create(); assert a1.getX() == a2.getX() assert a1.getY() == a2.getY() assert a1.getZ() == a2.getZ() Instance i2 = new Instance(); i2.set_class(\u0026#34;toto.titi.B\u0026#34;); // Nom plainement qualifié nécessaire i2.setX(3); i2.setY(4); B b1 = (B)i2.create(); assert b1.getX() == 3 assert b1.getY() == 4; } }     ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"59e372f34b145c6829cc200c92ce2ad1","permalink":"/courses/metamodelisation/tp6/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/metamodelisation/tp6/","section":"courses","summary":"Note Dans ce TP, vous allez mettre manipuler un type de modèle un peu différent de ceux que vous avez manipulé pendant les TPs précédent. Cette fois, vous n’utiliserez pas EMF ou PyEcore, mais vous vous allez manipuler directement le méta-modèle Java pour extraire de l’information, générer du code ou coder des fonctions utilitaires.","tags":null,"title":"","type":"courses"}]